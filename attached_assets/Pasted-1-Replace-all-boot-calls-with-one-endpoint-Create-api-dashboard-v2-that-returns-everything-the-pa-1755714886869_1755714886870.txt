1) Replace all boot calls with one endpoint

Create /api/dashboard/v2 that returns everything the page needs in one shot (projects, users, crews, tasksRange, budgetsByLoc, tasksByLoc). It parallelizes DB work and supports a fast ETag so 304s don’t scan rows.

// server/routes/dashboard.ts
import { Router } from "express";
import { db } from "../db";
import { sql } from "drizzle-orm";

const router = Router();

router.get("/dashboard/v2", async (req, res, next) => {
  try {
    const locIds = String(req.query.locationIds || "")
      .split(",").map(s => s.trim()).filter(Boolean).map(Number);
    const from = (req.query.from as string) ?? new Date().toISOString().slice(0,10);
    const to   = (req.query.to   as string) ?? from;

    // -------- fast "version probe" (no row scans) ----------
    const [tVer, pVer, uVer, cVer] = await Promise.all([
      db.execute(sql`
        SELECT COUNT(*)::int AS cnt, COALESCE(MAX(updated_at),'epoch'::timestamptz) AS mu
        FROM tasks WHERE task_date BETWEEN ${from}::date AND ${to}::date
      `),
      db.execute(sql`SELECT COUNT(*)::int AS cnt, COALESCE(MAX(updated_at),'epoch') AS mu FROM projects`),
      db.execute(sql`SELECT COUNT(*)::int AS cnt, COALESCE(MAX(updated_at),'epoch') AS mu FROM users`),
      db.execute(sql`SELECT COUNT(*)::int AS cnt, COALESCE(MAX(updated_at),'epoch') AS mu FROM crews`),
    ]);

    const pick = (x:any) => (Array.isArray(x) ? x[0] : x.rows[0]);
    const vTasks = pick(tVer), vProj = pick(pVer), vUsers = pick(uVer), vCrews = pick(cVer);

    const etag = `W/"v2:${from}:${to}:${vTasks.cnt}:${new Date(vTasks.mu).getTime()}:` +
                 `${vProj.cnt}:${new Date(vProj.mu).getTime()}:` +
                 `${vUsers.cnt}:${new Date(vUsers.mu).getTime()}:` +
                 `${vCrews.cnt}:${new Date(vCrews.mu).getTime()}"`;

    if (req.headers["if-none-match"] === etag) {
      res.setHeader("ETag", etag);
      res.setHeader("Cache-Control", "public, max-age=0, must-revalidate");
      return res.status(304).end();
    }

    // -------- actual data (parallel) ----------
    const [projects, users, crews, tasksRange, budgetsAll, tasksAll] = await Promise.all([
      db.execute(sql`SELECT id, name FROM projects ORDER BY name`),
      db.execute(sql`SELECT id, name, role FROM users ORDER BY name`),
      db.execute(sql`SELECT id, name FROM crews ORDER BY name`),
      db.execute(sql`
        SELECT id, name, location_id, project_id, task_date, status
        FROM tasks
        WHERE task_date BETWEEN ${from}::date AND ${to}::date
        ORDER BY task_date, location_id
        LIMIT 5000
      `),
      locIds.length
        ? db.execute(sql`SELECT * FROM budgets WHERE location_id = ANY(${locIds}::int[])`)
        : Promise.resolve({ rows: [] }),
      locIds.length
        ? db.execute(sql`SELECT * FROM tasks   WHERE location_id = ANY(${locIds}::int[])`)
        : Promise.resolve({ rows: [] }),
    ]);

    const rows = (x:any) => (Array.isArray(x) ? x : x.rows);

    // group by locationId for easy rendering
    const groupBy = <T extends Record<string, any>>(arr:T[], key:'location_id') =>
      arr.reduce<Record<string, T[]>>((acc, r:any) => {
        const k = String(r[key]);
        (acc[k] ||= []).push(r);
        return acc;
      }, {});

    const budgetsByLoc = groupBy(rows(budgetsAll), "location_id");
    const tasksByLoc   = groupBy(rows(tasksAll),   "location_id");

    res.setHeader("ETag", etag);
    res.setHeader("Cache-Control", "public, max-age=0, must-revalidate");
    res.json({
      projects:   rows(projects),
      users:      rows(users),
      crews:      rows(crews),
      tasksRange: rows(tasksRange),
      budgetsByLoc,
      tasksByLoc,
    });
  } catch (e) { next(e); }
});

export default router;


Add gzip to cut payload size:

// server/index.ts
import compression from "compression";
app.use(compression());

2) Indexes for the slow queries
// migrations/20250819_indexes.ts
import { sql } from "drizzle-orm";
export async function up(db:any){
  await db.execute(sql`CREATE INDEX IF NOT EXISTS idx_tasks_task_date          ON tasks(task_date)`);
  await db.execute(sql`CREATE INDEX IF NOT EXISTS idx_tasks_task_date_updated  ON tasks(task_date, updated_at)`);
  await db.execute(sql`CREATE INDEX IF NOT EXISTS idx_tasks_location_date      ON tasks(location_id, task_date)`);
  -- optionally: BRIN for very large tables
  await db.execute(sql`CREATE INDEX IF NOT EXISTS brin_tasks_task_date ON tasks USING BRIN(task_date)`);
}
export async function down(db:any){
  await db.execute(sql`DROP INDEX IF EXISTS brin_tasks_task_date`);
  await db.execute(sql`DROP INDEX IF EXISTS idx_tasks_location_date`);
  await db.execute(sql`DROP INDEX IF EXISTS idx_tasks_task_date_updated`);
  await db.execute(sql`DROP INDEX IF EXISTS idx_tasks_task_date`);
}


(Ensure your SQL uses WHERE task_date BETWEEN $1 AND $2 — don’t wrap the column in functions.)

3) Frontend: one query, nothing sequential
// Dashboard.tsx
import { useQuery } from "@tanstack/react-query";

export default function Dashboard({ locationIds, from, to }:{
  locationIds: string[]; from: string; to: string;
}) {
  const { data, isLoading, error } = useQuery({
    queryKey: ["dashboardV2", locationIds, from, to],
    queryFn: async () => {
      const url = `/api/dashboard/v2?locationIds=${encodeURIComponent(locationIds.join(","))}&from=${from}&to=${to}`;
      const r = await fetch(url, { credentials: "include" });
      if (!r.ok) throw new Error(`v2 failed ${r.status}`);
      return r.json();
    },
    staleTime: 300_000,
    refetchOnWindowFocus: false,
    refetchOnReconnect: false,
  });

  if (isLoading) return <div>Loading…</div>;
  if (error) return <div>Failed to load dashboard.</div>;

  return (
    <DashboardView
      projects={data.projects}
      users={data.users}
      crews={data.crews}
      tasksRange={data.tasksRange}
      budgetsByLoc={data.budgetsByLoc}
      tasksByLoc={data.tasksByLoc}
    />
  );
}


Delete/disable any legacy calls:

/api/projects, /api/users, /api/crews

/api/tasks/date-range/*

the old /bootstrap and separate /dashboard?locationIds=… call

Remove old …Loading variables (e.g., assignmentsLoading) from guards; use just isLoading.

4) Reduce perceived latency

Use the Supabase transaction pooler (:6543) and a single shared DB client.

Keep-alive:

import http from "http";
const server = http.createServer(app);
server.keepAliveTimeout = 75_000;
server.headersTimeout   = 76_000;


React Query defaults (avoid 304 churn):

new QueryClient({ defaultOptions:{ queries:{ staleTime:300_000, refetchOnWindowFocus:false, refetchOnReconnect:false } }});

Sanity checklist

 Replace Dashboard with a single useQuery → /api/dashboard/v2.

 Remove all per-resource boot queries and their …Loading flags.

 Apply the task indexes; verify with EXPLAIN ANALYZE.

 Confirm 304s on /dashboard/v2 are ~5–30ms (fast ETag).

 Enable gzip compression.

Result you should see in logs: one GET /api/dashboard/v2 (~250–450ms cold), minimal additional calls, and no more 575–760ms date-range requests or sequential waterfalls.