A) Prove and log that /api/dashboard/v2 is mounted

1) Add a tiny request logger (first middleware):

// server/index.ts
app.use((req, _res, next) => {
  console.log(`[REQ] ${req.method} ${req.originalUrl}`);
  next();
});


2) Add a V2 health route right next to your V2 router mount:

// server/index.ts (or wherever you mount routers)
app.get("/api/dashboard/v2/health", (_req, res) => {
  res.json({ ok: true, route: "/api/dashboard/v2/health" });
});


3) Mount the V2 router exactly once (avoid double-prefix bugs).
Pick one of these patterns; don’t mix them.

Pattern A (router path includes /dashboard/v2)

// server/routes/dashboardV2.ts
const router = Router();
router.get("/dashboard/v2", handler);    // <-- includes '/dashboard/v2'
export default router;

// server/index.ts
import dashboardV2 from "./routes/dashboardV2";
app.use("/api", dashboardV2);            // => /api/dashboard/v2


Pattern B (router path is just /v2)

// server/routes/dashboardV2.ts
const router = Router();
router.get("/v2", handler);              // <-- just '/v2'
export default router;

// server/index.ts
import dashboardV2 from "./routes/dashboardV2";
app.use("/api/dashboard", dashboardV2);  // => /api/dashboard/v2


Common pitfall: mounting with app.use("/api/dashboard/v2", router) and also defining router.get("/dashboard/v2", …) → final path becomes /api/dashboard/v2/dashboard/v2 and the client 404s.

4) Print the mounted routes once at startup (quick introspection):

// server/index.ts (after mounts, before listen)
function printRoutes(app: any) {
  const walk = (stack: any[], prefix = "") => {
    for (const layer of stack) {
      if (layer.route) {
        const methods = Object.keys(layer.route.methods).map(m => m.toUpperCase()).join(",");
        console.log(`[ROUTE] ${methods} ${prefix}${layer.route.path}`);
      } else if (layer.name === "router" && layer.handle?.stack) {
        walk(layer.handle.stack, prefix + (layer.regexp?.fast_star ? "" : (layer.regexp?.fast_slash ? "/" : (layer.regexp?.toString().match(/\\\/([^/?]+)/)?.[1] ? `/${layer.regexp.toString().match(/\\\/([^/?]+)/)[1]}` : ""))));
      }
    }
  };
  // @ts-ignore
  if (app._router?.stack) walk(app._router.stack);
}
printRoutes(app);


5) From the Replit shell, verify:

curl -i http://localhost:5000/api/dashboard/v2/health
curl -i "http://localhost:5000/api/dashboard/v2?locationIds=1,2&from=2025-08-19&to=2025-08-19"


You should see [REQ] GET /api/dashboard/v2/health in logs and 200 responses.

B) Ensure the client actually reaches the server

Vite proxy (dev):

// vite.config.ts
server: {
  proxy: {
    "/api": {
      target: "http://localhost:5000",
      changeOrigin: true,
    },
  },
}


If you’re not using a proxy, make sure fetch uses the full origin to the server and CORS allows it.

C) Flip the Dashboard to V2 only (kill the waterfall)

1) Single React Query against V2:

// client/src/components/Dashboard.tsx
import { useQuery } from "@tanstack/react-query";

export default function Dashboard({
  locationIds, from, to
}: { locationIds: string[]; from: string; to: string }) {

  const { data, isLoading, isFetching, error } = useQuery({
    queryKey: ["dashboardV2", locationIds, from, to],
    queryFn: async () => {
      const url = `/api/dashboard/v2?locationIds=${encodeURIComponent(locationIds.join(","))}&from=${from}&to=${to}`;
      const r = await fetch(url, { credentials: "include" });
      if (!r.ok) throw new Error(`V2 failed: ${r.status}`);
      return r.json();
    },
    staleTime: 300_000,
    refetchOnWindowFocus: false,
    refetchOnReconnect: false,
  });

  if (isLoading || isFetching) return <div className="p-6">Loading…</div>;
  if (error || !data) return <div className="p-6 text-red-600">Failed to load.</div>;

  return (
    <DashboardView
      projects={data.projects}
      users={data.users}
      crews={data.crews}
      tasksRange={data.tasksRange}
      budgetsByLoc={data.budgetsByLoc}
      tasksByLoc={data.tasksByLoc}
      locationIds={locationIds}
      from={from}
      to={to}
    />
  );
}


2) Hard-disable all legacy queries immediately (so you can see V2 in logs):

// Find any old useQuery calls and add enabled:false or remove them:
useQuery({ /* /api/dashboard/bootstrap */ } as any, { enabled: false });
useQuery({ /* /api/tasks/date-range */ } as any,   { enabled: false });
useQuery({ /* /api/projects */ } as any,          { enabled: false });
useQuery({ /* /api/users or /api/employees */ } as any, { enabled: false });
useQuery({ /* /api/crews */ } as any,             { enabled: false });


3) Replace any loading guards referencing removed queries (e.g. assignmentsLoading) with:

if (isLoading || isFetching) return …;


4) Bust any stale service-worker/browser cache temporarily:
Append &v=${Date.now()} to the V2 URL just for testing.

D) If V2 still doesn’t respond, fast triage

Confirm import path & filename case (dashboardV2.ts vs DashboardV2.ts).

Ensure the server entry actually imports the router (no circular import).

Check for earlier return res.status(304) paths that trigger before sending a body. For first test calls, set Cache-Control: no-store or remove ETag logic temporarily in V2 to guarantee 200 with JSON.

Ensure the mount order places your V2 route before a catch-all app.use('*', …) or static file handler.

E) Once V2 is live, re-enable fast caching (optional but recommended)

When /api/dashboard/v2 is confirmed working:

Keep the ETag-by-version logic inside V2 so 304s are instant.

Keep indexes on tasks(task_date) and (task_date, updated_at).

Prefer the Supabase transaction pooler (:6543) and a shared client.