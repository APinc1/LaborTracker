1) Fix the auto-increment (sequence/identity) after DB switch

When you migrate or insert IDs manually, the sequence can lag and cause “duplicate key” on the next insert. Run one of the following, depending on how tasks.id is defined.

A. If tasks.id is SERIAL or uses an attached sequence

-- find the attached sequence name (works for serial/int + default nextval)
SELECT pg_get_serial_sequence('public.tasks','id') AS seq;

-- then set it to max(id)
SELECT setval(
  pg_get_serial_sequence('public.tasks','id'),
  COALESCE((SELECT MAX(id) FROM public.tasks), 0),
  true  -- 'is_called' so next call returns max+1
);


B. If tasks.id is IDENTITY
(Recommended modern setup.)

-- ensure identity is defined
ALTER TABLE public.tasks
  ALTER COLUMN id
  ADD GENERATED BY DEFAULT AS IDENTITY;

-- (Optional) bump the identity to max(id)
DO $$
DECLARE v bigint;
BEGIN
  SELECT COALESCE(MAX(id),0) INTO v FROM public.tasks;
  PERFORM setval(pg_get_serial_sequence('public.tasks','id'), v, true);
END $$;


Repeat for any other tables that throw ID conflicts.

2) One-round-trip insert (CTE), production-ready

Here’s a compact CTE that (a) computes next_order and (b) inserts, (c) returns the new id. No client-side order math required. This stays fast even as the table grows.

// in your handler — using drizzle's raw sql helper
import { sql as raw } from "drizzle-orm";

const { locationId, name, startDate, finishDate, taskType = 'General', costCode = 'GEN' } = candidate;

const [row] = await db.execute(raw/*sql*/`
WITH agg AS (
  SELECT
    COALESCE(MAX(t."order"), -1) + 1 AS next_order
  FROM tasks t
  WHERE t.location_id = ${locationId}
),
ins AS (
  INSERT INTO tasks (
    location_id, name, "order", start_date, finish_date, task_type, cost_code
  )
  SELECT
    ${locationId},
    ${name},
    (SELECT next_order FROM agg),
    ${startDate}::date,
    ${finishDate}::date,
    ${taskType},
    ${costCode}
  RETURNING id
)
SELECT id FROM ins;
`);

const newId = row?.id;
return res.status(201).json({ id: newId });

If you need “next weekday after last_finish” when dependentOnPrevious:

Do it in SQL without a second round-trip:

WITH agg AS (
  SELECT
    COALESCE(MAX("order"), -1) + 1 AS next_order,
    MAX(finish_date) AS last_finish
  FROM tasks
  WHERE location_id = ${locationId}
),
ins AS (
  INSERT INTO tasks (location_id, name, "order", start_date, finish_date, task_type, cost_code)
  SELECT
    ${locationId},
    ${name},
    (SELECT next_order FROM agg),
    (
      CASE
        WHEN ${raw<boolean>`${!!req.body.dependentOnPrevious}` } AND (SELECT last_finish FROM agg) IS NOT NULL THEN
          CASE EXTRACT(DOW FROM (SELECT last_finish FROM agg))
            WHEN 6 THEN (SELECT last_finish FROM agg)::date + INTERVAL '2 day' -- Sat→Mon
            WHEN 0 THEN (SELECT last_finish FROM agg)::date + INTERVAL '1 day' -- Sun→Mon
            ELSE (SELECT last_finish FROM agg)::date
          END
        ELSE ${startDate}::date
      END
    ) AS start_date,
    (
      CASE
        WHEN ${raw<boolean>`${!!req.body.dependentOnPrevious}` } AND (SELECT last_finish FROM agg) IS NOT NULL THEN
          CASE EXTRACT(DOW FROM (SELECT last_finish FROM agg))
            WHEN 6 THEN (SELECT last_finish FROM agg)::date + INTERVAL '2 day'
            WHEN 0 THEN (SELECT last_finish FROM agg)::date + INTERVAL '1 day'
            ELSE (SELECT last_finish FROM agg)::date
          END
        ELSE ${finishDate}::date
      END
    ) AS finish_date,
    ${taskType},
    ${costCode}
  RETURNING id
)
SELECT id FROM ins;

3) Keep these guardrails (you already did most)

Singleton DB client; prepare:false on 6543 (PgBouncer tx pooler), pool max≈8–10.

No per-request SET statement_timeout (transaction pooling won’t keep it). Do timeouts at app level and rely on fast queries.

Compression off for POST; JSON limit ~128 KB.

Expose Server-Timing via CORS if you want to read it in the browser (exposedHeaders: ['Server-Timing']).